import io.github.groovymc.modsdotgroovy.ConvertToTomlTask
import net.darkhax.curseforgegradle.TaskPublishCurseForge
import groovy.transform.CompileStatic
import org.w3c.dom.Document
import org.w3c.dom.Element

plugins {
    id 'groovy'
    id 'maven-publish'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'io.github.groovymc.modsdotgroovy' version '1.0.4'
    id 'net.darkhax.curseforgegradle' version '1.0.11'
}

modsDotGroovy {
    dslVersion = '1.0.2' // Can be replaced with any existing DSL version
    automaticConfiguration = false
}

archivesBaseName = 'gml'
group = 'com.matyrobbrt.gml'

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

minecraft {
    mappings channel: 'parchment', version: '1.18.2-2022.07.17-1.19'
    runs {
        client {}
        server {}
    }
}

configurations {
    globalCompile
    compileOnly.extendsFrom(globalCompile)
    transformCompileOnly.extendsFrom(globalCompile)
    testCompileOnly.extendsFrom(globalCompile)
    modCompileOnly.extendsFrom(globalCompile)
    extensionCompileOnly.extendsFrom(globalCompile)

    globalAP
    annotationProcessor.extendsFrom(globalAP)
    transformAnnotationProcessor.extendsFrom(globalAP)
    testAnnotationProcessor.extendsFrom(globalAP)
    modAnnotationProcessor.extendsFrom(globalAP)

    groovy
    globalCompile.extendsFrom(groovy)

    include
}

sourceSets {
    transform {
        compileClasspath += configurations.getByName('minecraft')
    }

    test {
        compileClasspath += transform.output
    }
    extension {
        compileClasspath += configurations.getByName('minecraft')
    }
    mod {
        groovy {
            compileClasspath += extension.output
        }
        compileClasspath += transform.output
        compileClasspath += configurations.getByName('minecraft')
    }
}
tasks.create('testModsDotGroovyToToml', ConvertToTomlTask) {
    it.configureForSourceSet(sourceSets.test)
}
tasks.create('modModsDotGroovyToToml', ConvertToTomlTask) {
    it.configureForSourceSet(sourceSets.mod)
}

tasks.create('groovyJar', ManifestTransformingJiJ)

// GML is written in pure Groovy, so delete the empty java folder in each of the sourceSets
sourceSets.each { sourceSet ->
    final javaDir = file("src/${sourceSet.name}/java/")
    javaDir.deleteDir()
}

repositories {
    maven {
        name = 'Modding Inquisition Snapshots'
        url = 'https://maven.moddinginquisition.org/snapshots'
    }
    maven { url = 'https://maven.moddinginquisition.org/releases' }
}

final groovyLibs = [
        'stdlib', 'contracts', 'datetime',
        'nio', 'macro', 'macro-library',
        'templates', 'typecheckers',

        'dateutil', 'ginq',

        'toml', 'json'
]

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"

    groovyLibs.each {
        groovy groovyDep(it)
        groovyJar.setRange(groovyId(it), "[${groovy_version},${groovy_next_major})")
    }

    transformCompileOnly sourceSets.main.output

    testCompileOnly sourceSets.main.output
    testCompileOnly modsDotGroovy.mdgDsl()

    modCompileOnly sourceSets.main.output

    compileOnly 'com.matyrobbrt.enhancedgroovy:dsl:0.1.0'
    include("io.github.groovymc.cgl:cgl-${mc_version}-forge:${cgl_version}") {
        groovyJar.setRange("io.github.groovymc.cgl:cgl-${mc_version}-forge", "[${cgl_version},)")
    }
}

String groovyDep(String name) {
    return "${groovyId(name)}:${project.groovy_version}"
}

static String groovyId(String name) {
    return "org.apache.groovy:groovy${name == 'stdlib' ? '' : '-' + name}"
}

tasks.register('makeReadme', Copy) {
    final groovyLibsAsString = groovyLibs.join(', ')
    final expands = [
        'groovyVersion': project.groovy_version,
        'groovyLibs': groovyLibsAsString,

        'gmlVersion': '${gmlVersion}', // Thanks Gradle...
        'header': '<!-- This file is automatically generated, make any modifications to it in the `templates/README.MD` file, and then run the `makeReadme` Gradle task -->'
    ]
    it.inputs.properties expands

    it.from('templates/README.MD') {
        expand expands
    }
    it.destinationDir(project.rootDir)
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}

license {
    header = rootProject.file('LICENSE')
    exclude('**/mods.groovy')
}

final manifestAttr = [
        'Specification-Title': 'GroovyModLoader',
        'Specification-Vendor': 'GroovyMC',
        'Specification-Version': 1,
        'Implementation-Title': project.name,
        'Implementation-Version': project.version,
        'Implementation-Vendor' : 'GroovyMC',
        'Implementation-Timestamp': new Date().format(/yyyy-MM-dd'T'HH:mm:ssZ/),
        'BundledGroovyVersion': project.groovy_version,
        'GitCommit': getGitCommit(),
        'FMLModType' : 'LANGPROVIDER',
        'Built-on-Minecraft': project.mc_version,
        'DownloadHomepage': 'https://www.curseforge.com/minecraft/mc-mods/gml/files'
]

tasks.create('testJar', Jar) {
    group 'build'
    from sourceSets.test.output
    classifier 'test'
    manifest.attributes([
            'Specification-Title': 'no',
            'Specification-Vendor': 'Paint_Ninja',
            'Specification-Version': '1',
            'Implementation-Title': 'test',
            'Implementation-Version': '12.12',
            'Implementation-Vendor': 'Paint_Ninja',
            'Implementation-Timestamp': new Date().format("yyyy-MM-dd'T'HH:mm:ssZ")
    ])
}

tasks.named('groovyJar', ManifestTransformingJiJ).configure {
    group('build')
    output.set(project.file("$buildDir/libs/${archivesBaseName}-${version}-groovy.jar"))
    configurations = [project.configurations.groovy, project.configurations.include] // TODO cgl should be in another jar
    manifestAttributes.set(manifestAttr + [
            'Specification-Title': 'GML-GroovyFatJar',
            'Automatic-Module-Name': 'com.matyrobbrt.gml.groovyjij'
    ])

    [
            'jackson-databind', 'jackson-core', 'jackson-annotations'
    ].each {
        setUpperBound('com.fasterxml.jackson.core:' + it, '3.0.0')
    }
    setUpperBound('com.fasterxml.jackson.dataformat:jackson-dataformat-toml', '3.0.0')
}

tasks.create('modJar', Jar) {
    from sourceSets.mod.output
    manifest.attributes(manifestAttr - ['FMLModType': 'LANGPROVIDER'])
    classifier 'mod'
}

tasks.create('fullJar', Jar) {
    from sourceSets.main.output
    from sourceSets.transform.output
    from sourceSets.extension.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
    archiveClassifier.set 'all'
    group 'build'

    dependsOn(groovyJar)
    final File groovyOut = groovyJar.output.get().asFile
    from(groovyOut) {
        into 'META-INF/jarjar'
        rename groovyOut.name, 'groovy.jar'
    }

    dependsOn(modJar)
    final File modOut = modJar.archiveFile.get().asFile
    from(modOut) {
        into 'META-INF/jarjar'
        rename modOut.name, 'mod.jar'
    }

    final path = project.file("$buildDir/jarjar/metadata.json")
    doFirst {
        makeJarJar(path)
    }
    from(path) {
        into 'META-INF/jarjar'
    }
}

jar {
    from sourceSets.extension.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
}
java.withSourcesJar()

groovydoc {
    use = true
    source(sourceSets.transform.allSource)
    source(sourceSets.extension.allSource)
}

tasks.create('groovydocJar', Jar) {
    classifier 'javadoc'
    from groovydoc.destinationDir
    dependsOn(groovydoc)
}

final transformDest = new File(buildDir, 'libs/transform')
final transformAttr = manifestAttr + [
        'Specification-Title': 'GML-Transform'
]
tasks.create('transformJar', Jar) {
    from sourceSets.transform.output
    manifest.attributes(transformAttr)
    archiveBaseName.set('transform')
    destinationDirectory.set(transformDest)
}

tasks.create('transformSources', Jar) {
    from sourceSets.transform.allSource
    manifest.attributes(transformAttr)
    archiveBaseName.set('transform')
    archiveClassifier.set('sources')
    destinationDirectory.set(transformDest)
}

private void makeJarJar(File path) {
    final groovy = JiJUtils.makeJarJson('com.matyrobbrt.gml', 'groovy-fat', project.groovy_version, 'groovy.jar',
        "[$groovy_version,$groovy_next_major)")
    final mod = JiJUtils.makeJarJson('com.matyrobbrt.gml', 'mod', project.version.toString(), 'mod.jar', "[$version,)")
    JiJUtils.writeJiJ(path, groovy, mod)
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

tasks.register('publishCurseForge', TaskPublishCurseForge) {
    it.apiToken = findProperty('curseforgeKey')
    it.group = 'publishing'
    it.disableVersionDetection()

    var projectId = findProperty('curseforge_project')
    var modFile = it.upload(projectId, tasks.getByName('fullJar'))
    modFile.changelog = rootProject.file('changelog.txt')
    modFile.releaseType = findProperty('release_type')
    modFile.displayName = "$archivesBaseName-$version" as String
    modFile.addJavaVersion 'Java 17'
    modFile.addModLoader 'Forge'
    modFile.addGameVersion "$mc_version"

    it.dependsOn(fullJar)
    it.finalizedBy(makeReadme)
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            it.artifacts = [
                    jar, sourcesJar, fullJar, groovydocJar
            ]
            it.artifactId = 'gml'

            pom {
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    depsElem.appendChild createDependency(owner, project.group, 'transform', project.version, 'compile')
                    element.appendChild(depsElem)
                }
            }
        }
        register('transform', MavenPublication) {
            it.artifactId = 'transform'
            it.artifacts = [transformJar, transformSources]
            pom {
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    element.appendChild(depsElem)
                }
            }
        }
    }
    repositories {
        maven {
            name = 'ModdingInquisitionMavenRepo'
            url = 'https://maven.moddinginquisition.org/releases'
            credentials {
                username = findProperty('inquisitionMavenUser') ?: ''
                password = findProperty('inquisitionMavenPassword') ?: ''
            }
        }
    }
}

@CompileStatic
static Element createDependency(Document owner, String group, String name, String version, String scope) {
    var sub = owner.createElement('dependency')

    var groupEl = owner.createElement('groupId')
    groupEl.appendChild(owner.createTextNode(group))
    sub.appendChild groupEl

    var artEl = owner.createElement('artifactId')
    artEl.appendChild(owner.createTextNode(name))
    sub.appendChild artEl

    var verEl = owner.createElement('version')
    verEl.appendChild(owner.createTextNode(version))
    sub.appendChild verEl

    var scopeEl = owner.createElement('scope')
    scopeEl.appendChild(owner.createTextNode(scope))
    sub.appendChild scopeEl

    return sub
}

project(':script-mods').afterEvaluate {
    rootProject.dependencies {
        runtimeOnly files(
                tasks.fullJar.archiveFile.get().asFile,
                project(':script-mods').tasks.shadowJar.archiveFile.get().asFile
        )
    }
    rootProject.tasks.whenTaskAdded {
        if (it.name == 'runClient' || it.name == 'runServer') {
            it.dependsOn(':fullJar')
            it.dependsOn(':script-mods:shadowJar')
        }
    }
}