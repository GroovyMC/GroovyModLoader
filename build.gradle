import io.github.groovymc.modsdotgroovy.ConvertToTomlTask
import jij.transform.JiJDependencyFixerTransformer
import net.darkhax.curseforgegradle.TaskPublishCurseForge
import groovy.transform.CompileStatic
import org.w3c.dom.Document
import org.w3c.dom.Element
import jij.*

plugins {
    id 'groovy'
    id 'maven-publish'
    id 'org.cadixdev.licenser' version '0.6.1'
    id 'net.minecraftforge.gradle' version '5.1.+'
    id 'org.parchmentmc.librarian.forgegradle' version '1.+'
    id 'com.github.johnrengelman.shadow' version '7.1.2' apply false
    id 'io.github.groovymc.modsdotgroovy' version '1.0.4'
    id 'net.darkhax.curseforgegradle' version '1.0.11'
}

modsDotGroovy {
    dslVersion = '1.0.2' // Can be replaced with any existing DSL version
    automaticConfiguration = false
}

archivesBaseName = 'gml'
group = 'com.matyrobbrt.gml'

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

println "Java: ${System.getProperty 'java.version'}, JVM: ${System.getProperty 'java.vm.version'} (${System.getProperty 'java.vendor'}), Arch: ${System.getProperty 'os.arch'}"

minecraft {
    mappings channel: 'parchment', version: '1.18.2-2022.07.17-1.19'
    runs {
        client {}
        server {}
    }
}

allprojects {
    afterEvaluate {
        license {
            header = rootProject.file('license-header.txt')
            exclude('**/mods.groovy')
        }
    }
}

configurations {
    globalCompile
    compileOnly.extendsFrom(globalCompile)
    transformCompileOnly.extendsFrom(globalCompile)
    testCompileOnly.extendsFrom(globalCompile)
    modCompileOnly.extendsFrom(globalCompile)
    extensionCompileOnly.extendsFrom(globalCompile)

    globalAP
    annotationProcessor.extendsFrom(globalAP)
    transformAnnotationProcessor.extendsFrom(globalAP)
    testAnnotationProcessor.extendsFrom(globalAP)
    modAnnotationProcessor.extendsFrom(globalAP)

    groovy
    globalCompile.extendsFrom(groovy)

    include
    testConfig
}

sourceSets {
    transform {
        compileClasspath += configurations.getByName('minecraft')
    }

    test {
        compileClasspath += transform.output
    }
    extension {
        compileClasspath += configurations.getByName('minecraft')
    }
    mod {
        groovy {
            compileClasspath += extension.output
        }
        compileClasspath += transform.output
        compileClasspath += configurations.getByName('minecraft')
    }
}
tasks.create('testModsDotGroovyToToml', ConvertToTomlTask) {
    it.configureForSourceSet(sourceSets.test)
}
tasks.create('modModsDotGroovyToToml', ConvertToTomlTask) {
    it.configureForSourceSet(sourceSets.mod)
}

// GML is written in pure Groovy, so delete the empty java folder in each of the sourceSets
sourceSets.each { sourceSet ->
    final javaDir = file("src/${sourceSet.name}/java/")
    javaDir.deleteDir()
}

repositories {
    maven {
        name = 'Modding Inquisition Snapshots'
        url = 'https://maven.moddinginquisition.org/snapshots'
    }
    maven { url = 'https://maven.moddinginquisition.org/releases' }
}

final groovyLibs = [
        'stdlib', 'contracts', 'datetime',
        'nio', 'macro', 'macro-library',
        'templates', 'typecheckers',

        'dateutil', 'ginq',

        'toml', 'json'
]

dependencies {
    minecraft "net.minecraftforge:forge:${mc_version}-${forge_version}"

    groovyLibs.each {
        groovy groovyDep(it)
    }
    testConfig groovyDep('nio')

    transformCompileOnly sourceSets.main.output

    testCompileOnly sourceSets.main.output
    testCompileOnly modsDotGroovy.mdgDsl()

    modCompileOnly sourceSets.main.output

    compileOnly 'com.matyrobbrt.enhancedgroovy:dsl:0.1.0'
    include "io.github.groovymc.cgl:cgl-${mc_version}-forge:${cgl_version}"
}

String groovyDep(String name) {
    return "${groovyId(name)}:${project.groovy_version}"
}

static String groovyId(String name) {
    return "org.apache.groovy:groovy${name == 'stdlib' ? '' : '-' + name}"
}

tasks.register('makeReadme', Copy) {
    final groovyLibsAsString = groovyLibs.join(', ')
    final expands = [
        'groovyVersion': project.groovy_version,
        'groovyLibs': groovyLibsAsString,

        'gmlVersion': '${gmlVersion}', // Thanks Gradle...
        'header': '<!-- This file is automatically generated, make any modifications to it in the `templates/README.MD` file, and then run the `makeReadme` Gradle task -->'
    ]
    it.inputs.properties expands

    it.from('templates/README.MD') {
        expand expands
    }
    it.destinationDir(project.rootDir)
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}

final manifestAttr = [
        'Specification-Title': 'GroovyModLoader',
        'Specification-Vendor': 'GroovyMC',
        'Specification-Version': 1,
        'Implementation-Title': project.name,
        'Implementation-Version': project.version,
        'Implementation-Vendor' : 'GroovyMC',
        'BundledGroovyVersion': project.groovy_version,
        'GitCommit': getGitCommit(),
        'FMLModType' : 'LANGPROVIDER',
        'Built-on-Minecraft': project.mc_version,
        'DownloadHomepage': 'https://www.curseforge.com/minecraft/mc-mods/gml/files'
]

tasks.create('testJar', Jar) {
    group 'build'
    from sourceSets.test.output
    classifier 'test'
    manifest.attributes([
            'Specification-Title': 'no',
            'Specification-Vendor': 'Matyrobbrt',
            'Specification-Version': '1',
            'Implementation-Title': 'test',
            'Implementation-Version': '12.12',
            'Implementation-Vendor': 'Matyrobbrt'
    ])
}

tasks.create('groovyJar', JarInJarTask) {
    group('build')
    archiveBaseName.set('groovy-fat')
    fromConfiguration(project.configurations.groovy) {
        ['jackson-databind', 'jackson-core', 'jackson-annotations'].each {
            nextMajorBound "com.fasterxml.jackson.core:$it"
        }
        nextMajorBound 'com.fasterxml.jackson.dataformat:jackson-dataformat-toml'
        groovyLibs.each {
            nextMajorBound "org.apache.groovy:${it == 'stdlib' ? 'groovy' : ('groovy-' + it)}"
        }
    }
    manifest.attributes(manifestAttr + [
            'Specification-Title': 'GML-GroovyFatJar',
            'Automatic-Module-Name': 'com.matyrobbrt.gml.groovyjij'
    ])
    transformerFunction = {
        new JiJDependencyFixerTransformer(modType: 'LIBRARY', modulePrefix: 'com.matyrobbrt.gml.groovyjij')
    }
}

tasks.create('modJar', Jar) {
    from sourceSets.mod.output
    manifest.attributes(manifestAttr - ['FMLModType': 'LANGPROVIDER'])
    archiveBaseName.set('mod')
}

tasks.create('fullJar', JarInJarTask) {
    from sourceSets.main.output
    from sourceSets.transform.output
    from sourceSets.extension.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
    archiveClassifier.set 'all'
    group 'build'

    fromJar(tasks.modJar)
    fromJar(tasks.groovyJar)
    fromConfiguration(project.configurations.include) {
        nextMajorBound "io.github.groovymc.cgl:cgl-${mc_version}-forge"
    }
}
tasks.build.dependsOn tasks.fullJar
project(':script-mods').afterEvaluate {
    rootProject.tasks.named('fullJar', JarInJarTask) {
        fromJar(project(':script-mods').tasks.shadowJar)
    }
}

jar {
    from sourceSets.extension.output
    manifest.attributes(manifestAttr + [
            'Automatic-Module-Name': 'com.matyrobbrt.gml', 'FMLModType': 'LANGPROVIDER'
    ])
}
java.withSourcesJar()

groovydoc {
    use = true
    source(sourceSets.transform.allSource)
    source(sourceSets.extension.allSource)
}

tasks.create('groovydocJar', Jar) {
    classifier 'javadoc'
    from groovydoc.destinationDir
    dependsOn(groovydoc)
}

final transformDest = new File(buildDir, 'libs/transform')
final transformAttr = manifestAttr + [
        'Specification-Title': 'GML-Transform'
]
tasks.create('transformJar', Jar) {
    from sourceSets.transform.output
    manifest.attributes(transformAttr)
    archiveBaseName.set('transform')
    destinationDirectory.set(transformDest)
}

tasks.create('transformSources', Jar) {
    from sourceSets.transform.allSource
    manifest.attributes(transformAttr)
    archiveBaseName.set('transform')
    archiveClassifier.set('sources')
    destinationDirectory.set(transformDest)
}

static String getGitCommit() {
    def proc = 'git rev-parse --short HEAD'.execute()
    proc.waitFor()
    return proc.exitValue()? "ERROR(${proc.exitValue()})" : proc.text.trim()
}

tasks.register('publishCurseForge', TaskPublishCurseForge) {
    it.apiToken = findProperty('curseforgeKey')
    it.group = 'publishing'
    it.disableVersionDetection()

    var projectId = findProperty('curseforge_project')
    var modFile = it.upload(projectId, tasks.getByName('fullJar'))
    modFile.changelog = rootProject.file('changelog.txt')
    modFile.releaseType = findProperty('release_type')
    modFile.displayName = "$archivesBaseName-$version" as String
    modFile.addJavaVersion 'Java 17'
    modFile.addModLoader 'Forge'
    modFile.addGameVersion "$mc_version"

    it.dependsOn(fullJar)
    it.finalizedBy(makeReadme)
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            it.artifacts = [
                    jar, sourcesJar, fullJar, groovydocJar
            ]
            it.artifactId = 'gml'

            pom {
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    depsElem.appendChild createDependency(owner, project.group, 'transform', project.version, 'compile')
                    element.appendChild(depsElem)
                }
            }
        }
        register('transform', MavenPublication) {
            it.artifactId = 'transform'
            it.artifacts = [transformJar, transformSources]
            pom {
                withXml { XmlProvider xml ->
                    final element = xml.asElement()
                    var depsElem = element.getOwnerDocument().createElement('dependencies')
                    var owner = element.getOwnerDocument()
                    var deps = (DependencySet) project.configurations.groovy.getDependencies()
                    deps.each {
                        depsElem.appendChild createDependency(owner, it.group, it.name, it.version, 'compile')
                    }
                    element.appendChild(depsElem)
                }
            }
        }
    }
    repositories {
        maven {
            name = 'ModdingInquisitionMavenRepo'
            url = 'https://maven.moddinginquisition.org/releases'
            credentials {
                username = findProperty('inquisitionMavenUser') ?: ''
                password = findProperty('inquisitionMavenPassword') ?: ''
            }
        }
    }
}

@CompileStatic
static Element createDependency(Document owner, String group, String name, String version, String scope) {
    var sub = owner.createElement('dependency')

    var groupEl = owner.createElement('groupId')
    groupEl.appendChild(owner.createTextNode(group))
    sub.appendChild groupEl

    var artEl = owner.createElement('artifactId')
    artEl.appendChild(owner.createTextNode(name))
    sub.appendChild artEl

    var verEl = owner.createElement('version')
    verEl.appendChild(owner.createTextNode(version))
    sub.appendChild verEl

    var scopeEl = owner.createElement('scope')
    scopeEl.appendChild(owner.createTextNode(scope))
    sub.appendChild scopeEl

    return sub
}

dependencies {
    runtimeOnly files(
            tasks.fullJar.archiveFile.get().asFile
    )
}
tasks.whenTaskAdded {
    if (it.name == 'runClient' || it.name == 'runServer') {
        it.dependsOn(':fullJar')
    }
}