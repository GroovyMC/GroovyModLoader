import com.matyrobbrt.gradle.jarinjar.task.ForgeJarInJarTask

plugins {
    id 'java-library'
    id 'net.neoforged.gradle.userdev' version '7.0.96'
    id 'groovy'
    id 'signing'
    id 'maven-publish'
    id 'com.matyrobbrt.jarinjar' version '1.2.0'
    id 'org.groovymc.modsdotgroovy' version '2.0.0-beta.16'
    id 'io.github.gradle-nexus.publish-plugin' version '2.0.0-rc-1'
    id 'dev.lukebemish.managedversioning' version '1.2.8'
    id 'com.modrinth.minotaur' version '2.8.4'
    id 'net.darkhax.curseforgegradle' version '1.1.16'
}

group = 'org.groovymc.gml'

base {
    archivesName = 'gml'
}

java.withSourcesJar()

managedVersioning {
    versionFile.set rootProject.file('version.properties')

    gitHubActions {
        release {
            prettyName.set 'Release'
            workflowDispatch.set(true)
            gradleJob {
                name.set 'build'
                step {
                    setupGitUser()
                }
                readOnly.set false
                gradlew 'Tag Release', 'tagRelease'
                gradlew 'Build', 'build'
                step {
                    run.set 'git push && git push --tags'
                }
                gradlew 'Publish', 'publish', 'closeAndReleaseSonatypeStagingRepository', 'curseforge', 'modrinth'
                secret('CENTRAL_MAVEN_USER')
                secret('CENTRAL_MAVEN_PASSWORD')
                secret('GPG_SIGNING_KEY')
                secret('GPG_KEY_PASSWORD')
                secret('CURSEFORGE_TOKEN')
                secret('MODRINTH_TOKEN')
            }
        }
    }
}

managedVersioning.apply()

println "Building: $version"

// Mojang ships Java 17 to end users in 1.18+, so your mod should target Java 17.
java.toolchain.languageVersion = JavaLanguageVersion.of(17)

repositories {
    mavenCentral()
    mavenLocal()
}

sourceSets.each {
    def localRuntime = configurations.maybeCreate(it.getTaskName(null, 'localRuntime'))
    configurations.named(it.runtimeClasspathConfigurationName).configure {
        extendsFrom localRuntime
    }
}

configurations {
    javadocElements {
        canBeConsumed = true
        canBeResolved = false
        attributes {
            attribute(Usage.USAGE_ATTRIBUTE, objects.named(Usage.class, Usage.JAVA_RUNTIME))
            attribute(Category.CATEGORY_ATTRIBUTE, objects.named(Category.class, Category.DOCUMENTATION))
            attribute(Bundling.BUNDLING_ATTRIBUTE, objects.named(Bundling.class, Bundling.EXTERNAL))
            attribute(DocsType.DOCS_TYPE_ATTRIBUTE, objects.named(DocsType.class, DocsType.JAVADOC))
        }
    }
    include
    expose
    compileOnlyApi.extendsFrom expose
    localRuntime.extendsFrom expose
}

tasks.register('fullJar', ForgeJarInJarTask)

runs {
    configureEach {
        modSource project.sourceSets.main
    }

    client {
    }

    server {
        programArgument '--nogui'
    }
}

dependencies {
    implementation "net.neoforged:neoforge:${project.neo_version}"

    // TODO: remove and update in GML-core
    compileOnly "org.groovymc:groovybundler:2.1.2"

    expose "org.groovymc.gml:gml-core:${project.gml_core_version}"
    expose "org.groovymc.cgl:cgl-1.20.4-neoforge:${project.cgl_version}"

    include("org.groovymc.gml:gml-core:${project.gml_core_version}") {
        transitive = false
    }
    include("org.groovymc.cgl:cgl-1.20.4-neoforge:${project.cgl_version}") {
        transitive = false
    }
}

sourceSets.each {
    tasks.named(it.compileJavaTaskName, JavaCompile).configure {
        options.encoding = 'UTF-8' // Use the UTF-8 charset for Java compilation
    }
}

final manifestAttr = [
        'Specification-Title'   : 'GroovyModLoader',
        'Specification-Vendor'  : 'GroovyMC',
        'Specification-Version' : 1,
        'Implementation-Title'  : project.name,
        'Implementation-Version': project.version,
        'Implementation-Vendor' : 'GroovyMC',
        'GitCommit'             : managedVersioning.hash
]

processResources {
    exclude 'mods.groovy'
}

tasks.named('jar', Jar).configure {
    manifest.attributes(manifestAttr)
    archiveClassifier = 'slim'
}

tasks.named('fullJar', ForgeJarInJarTask).configure {
    from(zipTree(tasks.jar.archiveFile))
    dependsOn tasks.jar
    manifest.attributes(manifestAttr)
    archiveClassifier.set('')
    group('build')
    fromConfiguration(project.configurations.include)

    tasks.build.dependsOn(it)
}

tasks.withType(GroovyCompile).configureEach { GroovyCompile task ->
    task.groovyOptions.fork = true
    task.groovyOptions.encoding = 'UTF-8'
    task.groovyOptions.optimizationOptions.indy = true
}

groovydoc {
    use = true
}

tasks.register('groovydocJar', Jar) {
    archiveClassifier = 'javadoc'
    from groovydoc.destinationDir
    dependsOn(groovydoc)
}

tasks.named('build').configure {
    dependsOn tasks.groovydocJar
}

configurations.runtimeElements.artifacts.clear()
configurations.apiElements.artifacts.clear()

artifacts {
    javadocElements groovydocJar
    runtimeElements fullJar
    apiElements fullJar
}

project.components.named("java").configure {
    AdhocComponentWithVariants javaComponent = (AdhocComponentWithVariants) it
    javaComponent.addVariantsFromConfiguration(configurations.javadocElements) {}
}

void sharedMetadata(MavenPom it) {
    it.packaging = 'jar'
    it.url = 'https://github.com/GroovyMC/GroovyModLoader'
    it.inceptionYear = '2022'
    it.licenses {
        license {
            name = 'MIT'
            url = 'https://opensource.org/license/mit/'
        }
    }
    it.developers {
        developer {
            id = 'groovymc'
            name = 'GroovyMC'
            email = 'holdings@groovymc.org'
            url = 'https://github.com/GroovyMC/'
        }
    }
    it.scm {
        connection='scm:git:git://github.com/GroovyMC/GroovyModLoader.git'
        url='https://github.com/GroovyMC/GroovyModLoader'
    }
}

nexusPublishing {
    repositories {
        sonatype {
            username.set(System.getenv('CENTRAL_MAVEN_USER') ?: '')
            password.set(System.getenv('CENTRAL_MAVEN_PASSWORD') ?: '')
            nexusUrl.set(uri("https://s01.oss.sonatype.org/service/local/"))
        }
    }
}

publishing {
    publications {
        register('mavenJava', MavenPublication) {
            from components.java
            it.artifactId = base.archivesName.get()

            pom {
                name = 'GML'
                description = 'A language provider for NeoForge mods for Groovy'
                sharedMetadata(it)
            }
        }
    }
    repositories {
        maven {
            name 'repo'
            url file('repo')
        }
    }
}

if (System.getenv('GPG_SIGNING_KEY')) {
    signing {
        final signingKey = System.getenv('GPG_SIGNING_KEY') ?: ''
        final signingPassword = System.getenv('GPG_KEY_PASSWORD') ?: ''
        useInMemoryPgpKeys(signingKey, signingPassword)
        sign publishing.publications.mavenJava
        sign publishing.publications.transform
    }
}

// Publishing

def mcVersion() {
    String[] parts = project.neo_version.split('\\.')
    "1.${parts[0]}.${parts[1]}"
}

import net.darkhax.curseforgegradle.TaskPublishCurseForge

if (System.getenv('CURSEFORGE_TOKEN')) {
    tasks.register('curseforge', TaskPublishCurseForge) {
        dependsOn tasks.fullJar
        disableVersionDetection()
        apiToken = System.getenv('CURSEFORGE_TOKEN')
        def projectId = '661517'
        def mainFile = upload(projectId, tasks.fullJar)
        mainFile.displayName = "gml-$project.version"
        mainFile.releaseType = "${project.release_type}"
        mainFile.addModLoader('NeoForge')
        mainFile.addGameVersion(mcVersion())
        mainFile.changelog = ''
    }
}

if (System.getenv('MODRINTH_TOKEN')) {
    modrinth {
        detectLoaders.set(false)
        token = System.getenv('MODRINTH_TOKEN')
        projectId = 'zg2tT2Vu'
        versionNumber = "$project.version"
        versionType = "${project.release_type}"
        detectLoaders = false
        uploadFile = fullJar
        gameVersions = [mcVersion()]
        loaders = ['neoforge']
    }
}